
### 问题说明:

#### 问题描述

现在，场地上有2n个点围成一圈，按照顺序编号1,2,3,.....,2n，集合s={1,2,3,....,2n},总共有2n条边
之后从中选取n个点，成为集合p,对应数组p[i],i=1,2,.....,n
这样剩下的n个点组成集合q=s-p
现在需要对集合p中每一个点，都在q集合中找到一个点一一对应，组成(p[i],q[i])
对于每一对点，定义他的花费cost[i]为： (从编号p[i]到编号q[i]的环上距离)的平方。
环上距离指的是从p[i]走到q[i]最少经过的边数，即 min((p[i]-q[i]),2n-(p[i]-q[i]))
因此cost[i]=min((p[i]-q[i]),(2n-(p[i]-q[i])))^2或者min((p[i]-q[i])^2,(2n-(p[i]-q[i]))^2)  提示：这两个是等价的
定义这张图的一种配对的总花费cost_all为 \sum_{i=1}^{n} cost[i] ，即每一对的cost之和
现在，对于我给出的一组p，我想找到这张图的一种配对，使得总花费cost_all最小

#### 输入描述
第一行输入一个整数n
第二行n个数，表示集合p对应的编号。注意，无序。

#### 输出描述
输出第一行为总花费
之后n行，每行输出实际上的 p[i] -> q[i] 匹配。p[i]的要求和输入的顺序一致

#### 样例输入
4
2 3 5 7

#### 样例输出
4
2 -> 1
3 -> 4
5 -> 6
7 -> 8

### 你要做的：

按照顺序完成以下操作：
1.仔细阅读上面的问题，之后使用算法的思维，解答这道题。你要保证你的时间复杂度应该尽可能地小，并且任何情况下最终答案是正确的。
2.将算法思路和正确性的证明写在readme.md中
3.使用你的算法，编写c++代码，写在std.cpp中
4.使用暴力匹配的方式，编写c++代码，写在force.cpp中
5.写一个c++ 数据制造代码，可以自动随机生成一组输入数据，写在1.in中。保证n<=a。(你先定义a=1000)
6.写一个对拍程序，循环调用qwq次(你先定义qwq=100)，每次调用：
        数据制造代码生成一组输入数据
        将这组输入数据当作输入，分别运行std和force的程序，分别输出到1.out,1.ans中
        之后比较两个程序输出内容是否一致，如果不一致，则报警退出

------------------------------

现在，我固定n=4。
我在输入1234四个p了之后。
还会在q中选择一个点，比如q[i]=m。
你需要找到一个点k，保证：
    1.判断,k的对面(比如1-5互为对面，2-6互为对面)的标号一定在p中。
    2.如果m满足第一条判断，则k=m
    3.如果不满足，则你需要在m附近1格的位置找到k，保证|k-q[i]|最小，并且满足第一条。
我的输入会在第一行输入m
第二行输入p的那四个数，这四个数不带空格。
你需要先按照刚才的输出，输出p[i]和q[i]的对应关系。
然后输出k。
比如我输入：
6
2375
你的输出为：
2 -> 8
3 -> 1
5 -> 4
7 -> 6

安全点:6

同时，我输入的p可能带空格，也可能不带空格。，即可能是2375也有可能是2 3 7 5

---

