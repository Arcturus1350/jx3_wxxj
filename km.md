# 环形点匹配问题 - 算法设计与证明

## 问题描述

在一个由2n个点组成的环上，选取n个点作为集合p，剩余n个点组成集合q。需要将p和q中的点一一配对，使得总花费最小。每对点的花费定义为环上距离的平方。

## 算法设计

### 问题建模

这是一个**二分图最小权完美匹配问题**：
- 左侧节点：集合p中的n个点
- 右侧节点：集合q中的n个点  
- 边的权重：环上距离的平方

对于任意两点 p[i] 和 q[j]，环上距离为：
```
dist(p[i], q[j]) = min(|p[i] - q[j]|, 2n - |p[i] - q[j]|)
```

花费为：
```
cost(p[i], q[j]) = dist(p[i], q[j])^2
```

### 算法选择：KM算法

采用**Kuhn-Munkres算法**（KM算法）求解最小权完美匹配。

#### 算法核心思想

KM算法通过维护顶标（label）来寻找最优匹配：
1. 初始化顶标，使得对于所有边(i,j)，有 label[i] + label[j] >= weight[i][j]
2. 在相等子图（label[i] + label[j] = weight[i][j]的边构成的图）中寻找完美匹配
3. 如果找不到完美匹配，调整顶标，扩大相等子图
4. 重复直到找到完美匹配

#### 关键改进

由于KM算法标准实现是求**最大权匹配**，而本问题求最小权匹配，需要进行转换：
- 方法1：取权重的负数，最大化负权重等价于最小化正权重
- 方法2：用一个足够大的数减去所有权重

本实现采用**方法1**：权重取负数。

### 时间复杂度分析

- 预处理计算距离矩阵：O(n²)
- KM算法主体：O(n³)
- 总时间复杂度：**O(n³)**

对于n≤1000，这个复杂度是可接受的。

## 正确性证明

### 1. 问题等价性

原问题等价于在完全二分图中寻找权重和最小的完美匹配，这是经典的指派问题（Assignment Problem）。

### 2. KM算法正确性

KM算法的正确性基于以下定理：

**定理（König-Egerváry）**：在带权二分图中，如果存在顶标l使得：
- 对所有边(i,j)，有 l(i) + l(j) >= w(i,j)
- 在相等子图（l(i) + l(j) = w(i,j)）中存在完美匹配M

那么M就是原图的最大权完美匹配。

**证明思路**：
1. 对于最大权匹配问题，设最优匹配为M*，权重和为W*
2. KM算法找到的匹配M的权重和为W
3. 由顶标性质，W = Σ[l(i) + l(matched[i])] ≥ W*（对所有可能的匹配）
4. 同时M是相等子图中的完美匹配，所以W ≤ W*
5. 因此W = W*，M是最优匹配

### 3. 转换为最小权匹配

将权重取负数后：
- 原问题：min Σcost[i] 
- 转换为：max Σ(-cost[i])
- KM求出最大的Σ(-cost[i])，即最小的Σcost[i]

因此转换是正确的。

### 4. 环上距离的正确性

环上距离的计算公式已经考虑了环的双向性：
- 顺时针距离：|p[i] - q[j]|
- 逆时针距离：2n - |p[i] - q[j]|
- 最短距离：取两者的最小值

这保证了距离的对称性和最优性。

## 算法实现要点

1. **距离计算**：正确处理环形结构，考虑顺时针和逆时针两个方向
2. **权重转换**：使用负权重将最大权匹配转为最小权匹配  
3. **匹配记录**：记录每个p[i]对应的q[j]，按输入顺序输出
4. **数值范围**：注意权重可能很大（最大为n²），使用long long防止溢出

## 复杂度总结

- **时间复杂度**：O(n³)
- **空间复杂度**：O(n²)
- **适用范围**：n ≤ 10000（实际测试中n=1000运行时间在秒级）

## 暴力算法对比

暴力算法使用全排列枚举所有可能的匹配方案：
- **时间复杂度**：O(n! × n)
- **适用范围**：仅适用于n ≤ 10的小规模数据
- **作用**：用于验证最优算法的正确性

## 总结

本问题通过将环形匹配问题建模为二分图最小权完美匹配，使用经典的KM算法求解，保证了算法的正确性和效率。时间复杂度O(n³)能够满足n≤1000的数据规模要求。

